<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Stellar Map</title>
    <style>
      body {
        margin: 0;
      }

      #loading-screen {
        position: absolute;
        z-index: 2;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000000;
        opacity: 1;
        transition: 1s opacity;
      }

      #loading-screen.fade-out {
        opacity: 0;
      }
      #loaderTitle {
        width: 100%;
        position: relative;
        top: 47.5%;
        font-size: 35px;
        font-family: Helvetica, sans-serif;
        text-align: center;
        line-height: normal;
        font-weight: bold;
        color: rgba(0, 255, 255, 0.75);
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.95);
      }
      #loader {
        display: block;
        position: relative;
        left: 50%;
        top: 40%;
        width: 150px;
        height: 150px;
        margin: -75px 0 0 -75px;
        border-radius: 50%;
        border: 3px solid transparent;
        border-top-color: rgba(0, 255, 255, 0.75);
        -webkit-animation: spin 2s linear infinite;
        animation: spin 2s linear infinite;
      }
      #loader:before {
        content: '';
        position: absolute;
        top: 5px;
        left: 5px;
        right: 5px;
        bottom: 5px;
        border-radius: 50%;
        border: 3px solid transparent;
        border-top-color: rgba(0, 255, 255, 0.5);
        -webkit-animation: spin 3s linear infinite;
        animation: spin 3s linear infinite;
      }
      #loader:after {
        content: '';
        position: absolute;
        top: 15px;
        left: 15px;
        right: 15px;
        bottom: 15px;
        border-radius: 50%;
        border: 3px solid transparent;
        border-top-color: rgba(0, 255, 255, 0.25);
        -webkit-animation: spin 1.5s linear infinite;
        animation: spin 1.5s linear infinite;
      }
      @-webkit-keyframes spin {
        0% {
          -webkit-transform: rotate(0deg);
          -ms-transform: rotate(0deg);
          transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
          -ms-transform: rotate(360deg);
          transform: rotate(360deg);
        }
      }
      @keyframes spin {
        0% {
          -webkit-transform: rotate(0deg);
          -ms-transform: rotate(0deg);
          transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
          -ms-transform: rotate(360deg);
          transform: rotate(360deg);
        }
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .mapTitle {
        width: 100%;
        position: absolute;
        top: 15px;
        font-size: 35px;
        font-family: Helvetica, sans-serif;
        text-align: center;
        line-height: normal;
        font-weight: bold;
        color: rgba(255, 255, 255, 0.75);
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.95);
      }

      .menuElement {
        background: rgba(0, 70, 70, 0.75);
        box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.5);
        border: 1px solid rgba(127, 255, 255, 0.25);
        font-family: Helvetica, sans-serif;
        text-align: center;
        line-height: normal;
      }

      #data {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 300px;
        height: 250px;
        cursor: default;
      }
      .menuElement .title {
        position: absolute;
        top: 10px;
        left: 0px;
        right: 0px;
        font-size: 20px;
        font-weight: bold;
        color: rgba(255, 255, 255, 0.75);
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.95);
      }
      .menuElement .details {
        text-align: left;
        position: absolute;
        right: 0px;
        font-size: 16px;
        color: rgba(127, 255, 255, 0.75);
      }

      #designation {
        top: 40px;
        left: 10px;
      }

      #constellation {
        top: 60px;
        left: 10px;
      }

      #spectralType {
        top: 80px;
        left: 10px;
      }

      #luminosity {
        top: 100px;
        left: 10px;
      }

      #distance {
        top: 120px;
        left: 10px;
      }

      #coordinates {
        top: 140px;
        left: 10px;
      }

      #menu {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
      }

      button {
        background: rgba(0, 70, 70, 0.75);
        box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.5);
        border: 1px solid rgba(127, 255, 255, 0.25);
        font-size: 1.2em;
        color: rgba(127, 255, 255, 0.75);
        padding: 5px 10px;
        height: 3em;
        width: 7em;
        cursor: pointer;
      }
      button:hover {
        background-color: rgba(0, 255, 255, 0.5);
      }
      button:active {
        color: #000000;
        background-color: rgba(0, 255, 255, 0.75);
      }

      #legend {
        position: absolute;
        right: 20px;
        bottom: 20px;
        width: 300px;
        height: 250px;
        cursor: default;
      }
      .dot {
        position: absolute;
        text-align: left;
        left: 10px;
        height: 25px;
        width: 25px;
        border-radius: 50%;
      }
      #oType {
        background-color: #6573fa;
        top: 40px;
      }
      #bType {
        background-color: #8c99fc;
        top: 70px;
      }
      #aType {
        background-color: #cacefd;
        top: 100px;
      }
      #fType {
        background-color: #fff1d7;
        top: 130px;
      }
      #gType {
        background-color: #feda98;
        top: 160px;
      }
      #kType {
        background-color: #fda85a;
        top: 190px;
      }
      #mType {
        background-color: #fc6647;
        top: 220px;
      }
      .menuElement .legendDetails {
        text-align: left;
        position: absolute;
        top: 4px;
        left: 35px;
        font-size: 16px;
        white-space: nowrap;
        color: rgba(127, 255, 255, 0.75);
      }
    </style>

    <link
      href="css/style.css"
      type="text/css"
      rel="stylesheet"
      media="screen,projection"
    />
  </head>
  <section id="loading-screen">
    <div id="loader"></div>
    <div id="loaderTitle">Loading</div>
  </section>
  <body>
    <div class="mapTitle">Stellar Map</div>

    <div id="container"></div>

    <div class="menuElement" , id="data">
      <div class="title">Selected Star</div>
      <div class="details" , id="designation"></div>
      <div class="details" , id="constellation"></div>
      <div class="details" , id="spectralType"></div>
      <div class="details" , id="luminosity"></div>
      <div class="details" , id="distance"></div>
      <div class="details" , id="coordinates"></div>
    </div>

    <div class="menuElement" id="legend">
      <div class="title">Spectral Types</div>

      <span class="dot" , id="oType"
        ><span class="legendDetails">O-Type Star</span></span
      >
      <span class="dot" , id="bType"
        ><span class="legendDetails">B-Type Star</span></span
      >
      <span class="dot" , id="fType"
        ><span class="legendDetails">F-Type Star</span></span
      >
      <span class="dot" , id="aType"
        ><span class="legendDetails">A-Type Star</span></span
      >
      <span class="dot" , id="gType"
        ><span class="legendDetails">G-Type Star</span></span
      >
      <span class="dot" , id="kType"
        ><span class="legendDetails">K-Type Star</span></span
      >
      <span class="dot" , id="mType"
        ><span class="legendDetails">M-Type Star</span></span
      >
    </div>
    <div id="menu">
      <button id="sunButton">Back To Sol</button>
    </div>
    <script src="js/three.min.js"></script>
    <script src="../node_modules/three/examples/js/controls/OrbitControls.js"></script>
    <script src="../node_modules/d3/dist/d3.min.js"></script>
    <script src="../node_modules/camera-controls/dist/camera-controls.min.js"></script>

    <script>
      CameraControls.install({ THREE: THREE });

      class Star extends THREE.Mesh {
        constructor(
          geometry,
          material,
          designation,
          distance,
          luminosity,
          spectralType,
          constellation
        ) {
          super(geometry, material);
          this.designation = designation;
          this.distance = distance;
          this.luminosity = luminosity;
          this.spectralType = spectralType;
          this.constellation = constellation;
        }
      }

      const clock = new THREE.Clock();

      // Our Javascript will go here.
      // To display anything with three.js, we need scene, camera and renderer
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      camera.position.z = 15;

      const loadingManager = new THREE.LoadingManager(() => {
        const loadingScreen = document.getElementById('loading-screen');
        loadingScreen.classList.add('fade-out');

        // optional: remove loader from DOM via event listener
        loadingScreen.addEventListener('transitionend', onTransitionEnd);
      });

      const loader = new THREE.TextureLoader();
      const bgTexture = loader.load('img/milkyWay.jpg');
      scene.background = bgTexture;

      var renderer = new THREE.WebGLRenderer({ alpha: true });
      //renderer.setClearColor('rgb(0, 70, 70)', 0.75);
      renderer.setClearColor(0x000000, 1);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);

      var controls = new CameraControls(camera, renderer.domElement);

      var light = new THREE.PointLight(0xffff00);

      light.position.set(10, 0, 25);
      scene.add(light);

      camera.position.z = 1.5;
      var mouse = new THREE.Vector2(1, 1);
      var raycaster = new THREE.Raycaster();
      var INTERSECTED;
      var prevIntersected;
      var oldColor;

      // document.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('mousedown', onMouseDown, false);

      // load file
      const hygData = [];
      var selected;
      var designationDiv = document.getElementById('designation');
      var constellationDiv = document.getElementById('constellation');
      var spectralDiv = document.getElementById('spectralType');
      var luminosityDiv = document.getElementById('luminosity');
      var distanceDiv = document.getElementById('distance');
      var coordDiv = document.getElementById('coordinates');

      loadData();

      function loadData() {
        d3.csv('data/hygdata_prepared.csv').then(function(data) {
          data.forEach(function(d) {
            d.xCoord = +d.xCoord;
            d.yCoord = +d.yCoord;
            d.zCoord = +d.zCoord;
            d.scaledMagnitude = +d.scaledMagnitude;
            d.absoluteMagnitude = +d.absoluteMagnitude;
            d.spectralColor = +d.spectralColor;
            hygData.push(d);
          });

          for (var i = 0; i < hygData.length; i++) {
            var x = hygData[i].xCoord;
            var y = hygData[i].yCoord;
            var z = hygData[i].zCoord;
            var scaledMagnitude = hygData[i].scaledMagnitude;
            var spectralColor = hygData[i].spectralColor;
            var designation = hygData[i].designation;
            var distance = hygData[i].distance;
            var luminosity = hygData[i].luminosity;
            var spectralType = hygData[i].spectralType;
            var constellation = hygData[i].constellation;
            //console.log(hygData[i].spectralColor);

            var coordinates = new THREE.Vector3(x, y, z);
            var SphereGeometry = new THREE.SphereGeometry(
              scaledMagnitude / 1.75,
              8,
              8
            );
            var material = new THREE.MeshBasicMaterial({
              color: spectralColor
            });
            // var mesh = new THREE.Mesh(SphereGeometry, material);
            var mesh = new Star(
              SphereGeometry,
              material,
              designation,
              distance,
              luminosity,
              spectralType,
              constellation
            );

            mesh.position.x = x;
            mesh.position.y = y;
            mesh.position.z = z;

            if (i == 0) {
              selected = mesh;
              designationDiv.textContent = 'designation: ' + mesh.designation;
              constellationDiv.textContent =
                'constellation: ' + mesh.constellation;
              spectralDiv.textContent = 'spectral type: ' + mesh.spectralType;
              luminosityDiv.textContent = 'luminosity: ' + mesh.luminosity;
              distanceDiv.textContent = 'distance: ' + mesh.distance;
              coordDiv.textContent = 'coordinates: ' + mesh.position.x;

              prevIntersected = mesh;
            }

            scene.add(mesh);

            if (i == hygData.length - 1) {
              animate();
              controls.forward(
                camera.position.distanceTo(prevIntersected.position) - 0.5
              );
              controls.setTarget(
                prevIntersected.position.x,
                prevIntersected.position.y,
                prevIntersected.position.z,
                false
              );
              const loadingScreen = document.getElementById('loading-screen');
              loadingScreen.classList.add('fade-out');
              loadingScreen.addEventListener('transitionend', onTransitionEnd);
            }
          }
        });
      }

      ////////////////////////////////
      // Coordinations Scene
      ////////////////////////////////

      const sceneView = {
        left: 0,
        bottom: 0,
        width: 1.0,
        height: 1.0
      };

      const coordScene = new THREE.Scene();
      // coordScene.background = new THREE.Color('rgba(0, 70, 70, 0.75)');

      const coordSceneRatio = 0.15;
      const coordSceneSize = 1 - coordSceneRatio;
      const coordSceneView = {
        left: sceneView.left + coordSceneSize,
        bottom: sceneView.bottom + coordSceneSize,
        width: sceneView.width * coordSceneRatio,
        height: sceneView.height * coordSceneRatio
      };

      const coordCamera = new THREE.OrthographicCamera(
        10 / -2,
        10 / 2,
        10 / 2,
        10 / -2,
        0.011,
        1000
      );
      coordCamera.position.copy(camera.position);

      const axesHelper = new THREE.AxesHelper(3);
      coordScene.add(axesHelper);

      function onMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onMouseDown(event) {
        event.preventDefault();

        switch (event.which) {
          case 1: // left mouse click
            if (INTERSECTED) {
              var camerapos = camera.position;
              camerapos.setLength(0.5);

              controls.setLookAt(
                INTERSECTED.position.x - camerapos.x,
                INTERSECTED.position.y - camerapos.y,
                INTERSECTED.position.z - camerapos.z,
                INTERSECTED.position.x,
                INTERSECTED.position.y,
                INTERSECTED.position.z,
                true
              );

              // controls.lerpLookAt(
              //   camera.position.x,
              //   camera.position.y,
              //   camera.position.z,
              //   prevIntersected.position.x,
              //   prevIntersected.position.y,
              //   prevIntersected.position.z,
              //   INTERSECTED.position.x - camerapos.x,
              //   INTERSECTED.position.y - camerapos.y,
              //   INTERSECTED.position.z - camerapos.z,
              //   INTERSECTED.position.x,
              //   INTERSECTED.position.y,
              //   INTERSECTED.position.z,
              //   1,
              //   true
              // );
              // prevIntersected = INTERSECTED;
              // controls.saveState();
            }
            break;

          case 3: // right mouse click
            break;
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      var button = document.getElementById('sunButton');
      button.addEventListener(
        'click',
        function() {
          var camerapos = camera.position;
          camerapos.setLength(0.5);
          controls.setLookAt(
            prevIntersected.position.x - camerapos.x,
            prevIntersected.position.y - camerapos.y,
            prevIntersected.position.z - camerapos.z,
            prevIntersected.position.x,
            prevIntersected.position.y,
            prevIntersected.position.z,
            true
          );
        },
        false
      );

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = (canvas.clientWidth * pixelRatio) | 0;
        const height = (canvas.clientHeight * pixelRatio) | 0;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function renderSceneInfo(scene, camera, left, bottom, width, height) {
        const canvas = renderer.domElement;
        if (resizeRendererToDisplaySize(renderer)) {
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        // take the coordinate from 0-1 space, and put them
        // in screen space, baed on the size of the canvas.
        var nleft = Math.floor(canvas.width * left);
        var nbottom = Math.floor(canvas.height * bottom);
        var nwidth = Math.floor(canvas.width * width);
        var nheight = Math.floor(canvas.height * height);
        renderer.setViewport(nleft, nbottom, nwidth, nheight);
        renderer.setScissor(nleft, nbottom, nwidth, nheight);
        renderer.setScissorTest(true);
        // renderer.setClearColor("lightblue");
        renderer.render(scene, camera);
      }

      // Render the scene
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const hasControlsUpdated = controls.update(delta);
        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects(scene.children);
        if (intersects.length > 0) {
          // if the closest object intersected is not the currently stored intersection object
          if (intersects[0].object != INTERSECTED) {
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED)
              INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            // store reference to closest object as current intersection object
            INTERSECTED = intersects[0].object;
            // store color of closest object (for later restoration)
            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
            // set a new color for closest object
            INTERSECTED.material.color.setHex(0x00ff00);

            designationDiv.textContent =
              'designation: ' + INTERSECTED.designation;
            constellationDiv.textContent =
              'constellation: ' + INTERSECTED.constellation;
            spectralDiv.textContent =
              'spectral type: ' + INTERSECTED.spectralType;
            luminosityDiv.textContent = 'luminosity: ' + INTERSECTED.luminosity;
            distanceDiv.textContent = 'distance: ' + INTERSECTED.distance;
            coordDiv.textContent = 'coordinates: ' + INTERSECTED.position.x;
          }
        } // there are no intersections
        else {
          // restore previous intersection object (if it exists) to its original color
          if (INTERSECTED)
            INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
          // remove previous intersection object reference
          //     by setting current intersection object to "nothing"
          INTERSECTED = null;
        }

        renderSceneInfo(
          scene,
          camera,
          sceneView.left,
          sceneView.bottom,
          sceneView.width,
          sceneView.height
        );

        coordCamera.position.copy(camera.position);
        coordCamera.lookAt(coordScene.position);

        renderSceneInfo(
          coordScene,
          coordCamera,
          coordSceneView.left,
          coordSceneView.bottom,
          coordSceneView.width,
          coordSceneView.height
        );
      }

      function onTransitionEnd(event) {
        event.target.remove();
      }
    </script>
  </body>
</html>
